{
  "subjects": [{
    "name": "Python Complete Course",
    "slug": "python-complete",
    "icon": "üêç",
    "category": "programming",
    "level": "all",
    "order": 1,
    "topics": [{
      "title": "Python Lists",
      "slug": "python-lists",
      "description": "Master Python lists - creation, manipulation, methods, list comprehension, and advanced operations",
      "order": 5,
      "estimatedTime": 50,
      "difficulty": "medium",
      "contents": [
        {
          "title": "Introduction to Lists",
          "type": "text",
          "content": "Lists are ordered, mutable collections that can store multiple items of different types.\n\nList Characteristics:\n‚Ä¢ Ordered: Items have a defined order\n‚Ä¢ Mutable: Can be modified after creation\n‚Ä¢ Allow duplicates: Same value can appear multiple times\n‚Ä¢ Indexed: Access items by position (0-based)\n‚Ä¢ Dynamic: Can grow or shrink in size\n‚Ä¢ Heterogeneous: Can store different data types\n\nWhen to Use Lists:\n‚Ä¢ Store collections of items\n‚Ä¢ Maintain order of elements\n‚Ä¢ Need to modify data frequently\n‚Ä¢ Implement stacks and queues\n‚Ä¢ Store results from loops\n\nList vs Other Data Structures:\n‚Ä¢ List vs Tuple: Lists are mutable, tuples are immutable\n‚Ä¢ List vs Set: Lists allow duplicates and are ordered\n‚Ä¢ List vs Dict: Lists use numeric indices, dicts use keys\n\nCommon Operations:\n‚Ä¢ Adding elements (append, insert, extend)\n‚Ä¢ Removing elements (remove, pop, clear)\n‚Ä¢ Accessing elements (indexing, slicing)\n‚Ä¢ Searching (in, index, count)\n‚Ä¢ Sorting (sort, sorted, reverse)",
          "order": 1
        },
        {
          "title": "Creating and Accessing Lists",
          "type": "code",
          "content": "# Creating lists\nfruits = ['Apple', 'Banana', 'Mango', 'Orange']\nnumbers = [1, 2, 3, 4, 5]\nmixed = [1, 'Hello', 3.14, True, [1, 2]]\nempty = []\n\nprint(fruits)   # ['Apple', 'Banana', 'Mango', 'Orange']\nprint(numbers)  # [1, 2, 3, 4, 5]\nprint(mixed)    # [1, 'Hello', 3.14, True, [1, 2]]\n\n# Using list() constructor\nletters = list('Python')\nprint(letters)  # ['P', 'y', 't', 'h', 'o', 'n']\n\nrange_list = list(range(1, 6))\nprint(range_list)  # [1, 2, 3, 4, 5]\n\n# Accessing elements\nfruits = ['Apple', 'Banana', 'Mango', 'Orange']\n\nprint(fruits[0])   # Apple (first)\nprint(fruits[1])   # Banana\nprint(fruits[3])   # Orange (last)\n# print(fruits[4])  # IndexError\n\n# Negative indexing\nprint(fruits[-1])  # Orange (last)\nprint(fruits[-2])  # Mango (second last)\nprint(fruits[-4])  # Apple (first)\n\n# List length\nprint(len(fruits))  # 4\n\n# Slicing\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nprint(numbers[2:5])    # [2, 3, 4]\nprint(numbers[:5])     # [0, 1, 2, 3, 4]\nprint(numbers[5:])     # [5, 6, 7, 8, 9]\nprint(numbers[::2])    # [0, 2, 4, 6, 8] (every 2nd)\nprint(numbers[::-1])   # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] (reverse)\n\n# Nested lists (2D lists)\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\nprint(matrix[0])      # [1, 2, 3]\nprint(matrix[0][0])   # 1\nprint(matrix[1][2])   # 6\nprint(matrix[2][1])   # 8",
          "codeLanguage": "python",
          "order": 2,
          "examples": [
            {
              "title": "Modifying Lists",
              "code": "# Changing elements\nfruits = ['Apple', 'Banana', 'Mango']\nfruits[1] = 'Orange'\nprint(fruits)  # ['Apple', 'Orange', 'Mango']\n\n# Changing multiple elements\nnumbers = [1, 2, 3, 4, 5]\nnumbers[1:4] = [20, 30, 40]\nprint(numbers)  # [1, 20, 30, 40, 5]\n\n# append() - add single item at end\nfruits = ['Apple', 'Banana']\nfruits.append('Mango')\nprint(fruits)  # ['Apple', 'Banana', 'Mango']\n\n# insert() - add at specific position\nfruits.insert(1, 'Orange')\nprint(fruits)  # ['Apple', 'Orange', 'Banana', 'Mango']\n\n# extend() - add multiple items\nfruits.extend(['Grapes', 'Kiwi'])\nprint(fruits)  # ['Apple', 'Orange', 'Banana', 'Mango', 'Grapes', 'Kiwi']\n\n# remove() - remove specific item\nfruits.remove('Orange')\nprint(fruits)  # ['Apple', 'Banana', 'Mango', 'Grapes', 'Kiwi']\n\n# pop() - remove and return last item\nlast = fruits.pop()\nprint(last)    # Kiwi\nprint(fruits)  # ['Apple', 'Banana', 'Mango', 'Grapes']\n\n# pop(index) - remove at specific position\nsecond = fruits.pop(1)\nprint(second)  # Banana\nprint(fruits)  # ['Apple', 'Mango', 'Grapes']\n\n# clear() - remove all items\nfruits.clear()\nprint(fruits)  # []\n\n# del - delete items or entire list\nnumbers = [1, 2, 3, 4, 5]\ndel numbers[2]  # Delete at index 2\nprint(numbers)  # [1, 2, 4, 5]\n\ndel numbers[1:3]  # Delete slice\nprint(numbers)  # [1, 5]",
              "explanation": "Lists are mutable, so you can modify them after creation. Use append(), insert(), extend() to add items and remove(), pop(), clear() to remove items."
            }
          ]
        }
      ]
    }]
  }]
}
